plugins {
    id 'java'
    id 'org.springframework.boot' version '3.4.5'
    id 'io.spring.dependency-management' version '1.1.7'
}
ext {
    springBootVersion = '3.2.5'
}
group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(20)
    }
    sourceCompatibility = JavaVersion.VERSION_17  // исходный код совместим с Java 17
    targetCompatibility = JavaVersion.VERSION_17  // байт-код под Java 17
}

repositories {
    mavenCentral()
}


dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-web-services'

    developmentOnly 'org.springframework.boot:spring-boot-devtools'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    implementation 'at.favre.lib:bcrypt:0.9.0'
    implementation 'org.postgresql:postgresql:42.4.5'


}

tasks.named('test') {
    useJUnitPlatform()
}

tasks.register('welcome') {
    group = 'custom'
    doLast {
        println "welcome from katya pim"
    }
}

tasks.register('custom-compile', Exec) {
    group = 'custom'
    description = 'Ручная компиляция исходников через javac'

    def srcDirs = sourceSets.main.java.srcDirs
    def javaFiles = files(srcDirs)
            .asFileTree
            .matching { include '**/*.java' }
            .files
            .toList()

    def outputDir = layout.buildDirectory.dir("classes/java/main").get().asFile

    inputs.files javaFiles
    outputs.dir outputDir

    doFirst {
        outputDir.mkdirs()
    }

    // формируем classpath
    def deps = sourceSets.main.compileClasspath.asPath
    def cp = [deps, outputDir.absolutePath].join(File.pathSeparator)

    println cp


    commandLine = ['javac',
                    '-parameters',
                   '-d', outputDir.absolutePath,
                   '-cp', cp] + javaFiles.collect { it.absolutePath }

    doLast {
        println "✅все исходные файлы скомпилированы в: ${outputDir.absolutePath.replace(projectDir.absolutePath + '/', '')}"
    }
}

tasks.register('custom-build', Jar) {
    group = 'custom'
    description = 'компиляция исходных кодов проекта и их упаковка в исполняемый jar-архив. Компиляцию исходных кодов реализовать посредством вызова цели compile'

    def libsDir = layout.buildDirectory.dir("libs/lib").get().asFile.absolutePath

    dependsOn 'custom-compile'     //  компиляция + копирование lib

    archiveBaseName = project.name
    archiveVersion  = project.version.toString()

    copy{
        from configurations.runtimeClasspath
        into libsDir
    }

    from sourceSets.main.output

    manifest {
        attributes 'Main-Class': 'com.example.web4_2.Web4Application'

        def cpEntries = configurations.runtimeClasspath.files.collect {
            "lib/${it.name}"
        }
        attributes 'Class-Path': cpEntries.join(' ')
    }

    destinationDirectory = layout.buildDirectory.dir("libs")

    doLast {
        println "✅jar-архив собран в: ${archiveFile.get().asFile.absolutePath.replace(projectDir.absolutePath + '/', '')}"
    }
}


tasks.register('custom-clean', Exec) {
    group = "custom"
    description = "удаление скомпилированных классов, всех временных файлови jar-архива"

    def buildDir = layout.buildDirectory.get().asFile.absolutePath
    println buildDir

    commandLine "rm", "-rf", buildDir

    doLast {
        println "✅все скомпилированные классы и jar-архивы удалены"
    }
}

tasks.register("custom-native2ascii") {

    group = "custom"
    description = "преобразование native2ascii для копий файлов локализации " +
            "(для тестирования сценария все строковые параметры необходимо вынести из классов в файлы локализации)"

    def convertToUnicode = new GroovyShell().evaluate(file('scripts/convertToUnicode.groovy'))


    def inputDir = file("src/main/resources/")
    def outputDir = layout.buildDirectory.dir("native2ascii").get().asFile

    inputs.dir inputDir
    outputs.dir outputDir

    doLast {
        if (!outputDir.exists()) {
            outputDir.mkdirs()
        }
        // Process each .properties file in the input directory
        fileTree(inputDir).matching {
            include "**/messages*.properties"
        }.each { file ->
            def relativePath = inputDir.toPath().relativize(file.toPath()).toString()
            def outputFile = new File(outputDir, relativePath)
            outputFile.parentFile.mkdirs()
            println "converting: ${file}"
            outputFile.withWriter("UTF-8") { writer ->
                file.eachLine("UTF-8") { line ->
                    writer.writeLine((String) convertToUnicode(line))
                }
            }
        }
        println "✅конвертация завершена. результат в: ${outputDir}"
    }

}

tasks.register("custom-scp", Exec) {
    group = "custom"
    description = "перемещение собранного проекта по scp на выбранный сервер по завершению сборки. Предварительно необходимо выполнить сборку проекта (цель build)"

    dependsOn("custom-build")

    def jarFile = layout.buildDirectory.file("libs/${project.name}-${project.version}.jar").get().asFile.absolutePath

    def remoteHost = "helios.se.ifmo.ru"
    def remoteUser = "s409342"
    def remoteDirWebLab4 = "~/web_lab4"


    doFirst {
        println "Copying JAR to ${remoteUser}@${remoteHost}:${remoteDirWebLab4}"
    }

    commandLine "scp", "-P 2222", jarFile, "${remoteUser}@${remoteHost}:${remoteDirWebLab4}"

    doLast {
        println '✅jar-архив успешно скопирован на удаленный сервер'
    }
}

tasks.register("custom-xml") {
    group = "custom"
    description = "валидация всех xml-файлов в проекте"

    def xmlFilesDir = layout.projectDirectory.dir("src/main/resources").asFileTree // путь к директории с xml-файлами

    doLast {
        def script = new GroovyShell().parse(file('scripts/validateXml.groovy'))

        xmlFilesDir.each { file ->
            if (file.absolutePath.endsWith(".xml")) {
                println "валидирую файл: ${file.name}\n"
                script.validateXmlFile(file)
            }

        }
        println "✅валидация успешно завершена"
    }
}

