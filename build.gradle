plugins {
    id 'java'
    id 'org.springframework.boot' version '3.4.5'
    id 'io.spring.dependency-management' version '1.1.7'
}
ext {
    springBootVersion = '3.2.5'
}
group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(20)
    }
    sourceCompatibility = JavaVersion.VERSION_17  // исходный код совместим с Java 17
    targetCompatibility = JavaVersion.VERSION_17  // байт-код под Java 17
}

repositories {
    mavenCentral()
}


dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-web-services'

    developmentOnly 'org.springframework.boot:spring-boot-devtools'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    implementation 'at.favre.lib:bcrypt:0.9.0'
    implementation 'org.postgresql:postgresql:42.4.5'


}

tasks.named('test') {
    useJUnitPlatform()
}

tasks.register('welcome') {
    group = 'custom'
    doLast {
        println "welcome from katya pim"
    }
}

tasks.register('custom-compile', Exec) {
    group = 'custom'
    description = 'Ручная компиляция исходников через javac'

    def srcDirs = sourceSets.main.java.srcDirs
    def javaFiles = files(srcDirs)
            .asFileTree
            .matching { include '**/*.java' }
            .files
            .toList()

    def outputDir = layout.buildDirectory.dir("classes/java/main").get().asFile

    inputs.files javaFiles
    outputs.dir outputDir

    doFirst {
        outputDir.mkdirs()
    }

    // формируем classpath
    def deps = sourceSets.main.compileClasspath.asPath
    def cp = [deps, outputDir.absolutePath].join(File.pathSeparator)



    commandLine = ['javac',
                    '-parameters',
                   '-d', outputDir.absolutePath,
                   '-cp', cp] + javaFiles.collect { it.absolutePath }

    doLast {
        println "✅все исходные файлы скомпилированы в: ${outputDir.absolutePath.replace(projectDir.absolutePath + '/', '')}"
    }
}

tasks.register('custom-build', Jar) {
    group = 'custom'
    description = 'компиляция исходных кодов проекта и их упаковка в исполняемый jar-архив. Компиляцию исходных кодов реализовать посредством вызова цели compile'

    def libsDir = layout.buildDirectory.dir("libs/lib").get().asFile.absolutePath

    dependsOn 'custom-compile'     //  компиляция + копирование lib

    archiveBaseName = project.name
    archiveVersion  = project.version.toString()

    copy{
        from configurations.runtimeClasspath
        into libsDir
    }

    from sourceSets.main.output

    manifest {
        attributes 'Main-Class': 'com.example.web4_2.Web4Application'

        def cpEntries = configurations.runtimeClasspath.files.collect {
            "lib/${it.name}"
        }
        attributes 'Class-Path': cpEntries.join(' ')
    }

    destinationDirectory = layout.buildDirectory.dir("libs")

    doLast {
        println "✅jar-архив успешно собран в: ${archiveFile.get().asFile.absolutePath.replace(projectDir.absolutePath + '/', '')}"
    }
}


tasks.register('custom-clean', Exec) {
    group = "custom"
    description = "удаление скомпилированных классов, всех временных файлови jar-архива"

    def buildDir = layout.buildDirectory.get().asFile.absolutePath

    commandLine "rm", "-rf", buildDir

    doLast {
        println "✅все скомпилированные классы и jar-архивы удалены"
    }
}

tasks.register("custom-native2ascii") {

    group = "custom"
    description = "преобразование native2ascii для копий файлов локализации " +
            "(для тестирования сценария все строковые параметры необходимо вынести из классов в файлы локализации)"

    def convertToUnicode = new GroovyShell().evaluate(file('scripts/convertToUnicode.groovy'))


    def inputDir = file("src/main/resources/")
    def outputDir = layout.buildDirectory.dir("native2ascii").get().asFile

    inputs.dir inputDir
    outputs.dir outputDir

    doLast {
        if (!outputDir.exists()) {
            outputDir.mkdirs()
        }
        // Process each .properties file in the input directory
        fileTree(inputDir).matching {
            include "**/messages*.properties"
        }.each { file ->
            def relativePath = inputDir.toPath().relativize(file.toPath()).toString()
            def outputFile = new File(outputDir, relativePath)
            outputFile.parentFile.mkdirs()
            println "converting: ${file}"
            outputFile.withWriter("UTF-8") { writer ->
                file.eachLine("UTF-8") { line ->
                    writer.writeLine((String) convertToUnicode(line))
                }
            }
        }
        println "✅конвертация завершена. результат в: ${outputDir}"
    }

}

tasks.register("custom-scp", Exec) {
    group = "custom"
    description = "перемещение собранного проекта по scp на выбранный сервер по завершению сборки. Предварительно необходимо выполнить сборку проекта (цель build)"

    dependsOn("custom-build")

    def jarFile = layout.buildDirectory.file("libs/${project.name}-${project.version}.jar").get().asFile.absolutePath

    def remoteHost = "helios.se.ifmo.ru"
    def remoteUser = "s409342"
    def remoteDirWebLab4 = "~/web_lab4"


    doFirst {
        println "Copying JAR to ${remoteUser}@${remoteHost}:${remoteDirWebLab4}"
    }

    commandLine "scp", "-P 2222", jarFile, "${remoteUser}@${remoteHost}:${remoteDirWebLab4}"

    doLast {
        println '✅jar-архив успешно скопирован на удаленный сервер'
    }
}

tasks.register("xml") {
    group = "custom"
    description = "валидация всех xml-файлов в проекте"

    def xmlFilesDir = layout.projectDirectory.dir("src/main/resources").asFileTree // путь к директории с xml-файлами

    doLast {
        def script = new GroovyShell().parse(file('scripts/validateXml.groovy'))

        xmlFilesDir.each { file ->
            if (file.absolutePath.endsWith(".xml")) {
                println "валидирую файл: ${file.name}\n"
                script.validateXmlFile(file)
            }

        }
        println "✅валидация успешно завершена"
    }
}

tasks.register("music"){
    group = "custom"
    description = "воспроизведение музыки по завершению сборки (цель build)"

    dependsOn "custom-build"

    def musicFile = file("src/main/resources/Макс Корж - Малый повзрослел.mp3") // путь до твоего файла

    doLast {
        if (!musicFile.exists()) {
            throw new GradleException("не будет подлой еврейской музыки, файл не найден: ${musicFile} (")
        }

        exec {
            executable = 'afplay'
            args = [musicFile.absolutePath]
        }
        println "✅музыка"
    }
}



import java.security.MessageDigest

tasks.register('doc') {
    group = 'custom'
    description = 'добавление в MANIFEST.MF MD5 и SHA-1 файлов проекта, а также генерация и добавление в архив javadoc по всем классам проекта.'

    dependsOn 'custom-compile'

    def outputDir = layout.buildDirectory.dir("classes/java/main/com/example/web4_2").get().asFile
    def manifestFile = layout.buildDirectory.file("tmp/custom-build/MANIFEST.MF").get().asFile
    def javadocDir = layout.buildDirectory.dir("docs/javadoc").get().asFile
    def javadocJar = layout.buildDirectory.file("docs/javadoc.jar").get().asFile

    doLast {
        println "генерирую контрольные суммы MD5 SHA-1..."

        def files = outputDir.listFiles().findAll { it.isFile() }

        def md5Digest = MessageDigest.getInstance("MD5")
        def sha1Digest = MessageDigest.getInstance("SHA-1")

        def md5Strings = []
        def sha1Strings = []

        files.each { file ->
            def bytes = file.bytes
            md5Digest.update(bytes)
            sha1Digest.update(bytes)

            def md5Hex = md5Digest.digest().encodeHex().toString()
            def sha1Hex = sha1Digest.digest().encodeHex().toString()

            md5Strings << "${file.name}: $md5Hex"
            sha1Strings << "${file.name}: $sha1Hex"

            // Обнуляем digest после каждого файла
            md5Digest.reset()
            sha1Digest.reset()
        }

        // Дописываем в MANIFEST
        manifestFile.parentFile.mkdirs()
        manifestFile.text += "\r\n" // переход для новых записей
        manifestFile.text += "MD5-Checksums: ${md5Strings.join(', ')}\r\n"
        manifestFile.text += "SHA1-Checksums: ${sha1Strings.join(', ')}\r\n"

        println "MD5 и SHA-1 добавлены в манифест"

        println "генерирую Javadoc..."

        ant.javadoc(
                destdir: javadocDir,
                sourcepath: sourceSets.main.java.srcDirs.join(File.pathSeparator),
                packagenames: "*",
                classpath: configurations.runtimeClasspath.asPath,
                encoding: "UTF-8"
        )

        ant.jar(
                destfile: javadocJar,
                basedir: javadocDir
        )

        println "✅ документация Javadoc успешно содана: ${javadocJar}"
    }
}
