plugins {
    id 'java'
    id 'org.springframework.boot' version '3.4.5'
    id 'io.spring.dependency-management' version '1.1.7'
}
ext {
    springBootVersion = '3.2.5'
    useAltSrc = false
}
group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(20)
    }
    sourceCompatibility = JavaVersion.VERSION_17  // исходный код совместим с Java 17
    targetCompatibility = JavaVersion.VERSION_17  // байт-код под Java 17
}

repositories {
    mavenCentral()
}


dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-web-services'

    developmentOnly 'org.springframework.boot:spring-boot-devtools'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    implementation 'at.favre.lib:bcrypt:0.9.0'
    implementation 'org.postgresql:postgresql:42.4.5'
}

tasks.named('test') {
    useJUnitPlatform()
    enable = false
}

tasks.register('welcome') {
    group = 'custom'
    doLast {
        println "welcome from katya pim"
    }
}


tasks.register('custom-compile', Exec) {
    group = 'custom'
    description = 'компиляция исходных кодов проекта'

    def outputDir = layout.buildDirectory.dir("classes/java/main").get().asFile

    doFirst {
        def javaFiles = files(project.ext.useAltSrc ? layout.projectDirectory.dir("altSrc").asFile : sourceSets.main.java.srcDirs)
                .asFileTree
                .matching { include '**/*.java' }
                .files
                .toList()

        // формируем classpath
        def deps = sourceSets.main.compileClasspath.asPath + ":" + sourceSets.test.compileClasspath.asPath
        def cp = [deps, outputDir.absolutePath].join(File.pathSeparator)

        delete(outputDir) // удаляем старые классы

        commandLine = ['javac',
                       '-parameters',
                       '-d', outputDir.absolutePath,
                       '-cp', cp] + javaFiles.collect { it.absolutePath }
    }
    doLast {
        println "✅все исходные файлы скомпилированы в: ${outputDir.absolutePath.replace(projectDir.absolutePath + '/', '')}"
    }
}

tasks.register('custom-build', Jar) {
    group = 'custom'
    description = 'компиляция исходных кодов проекта и их упаковка в исполняемый jar-архив. Компиляцию исходных кодов реализовать посредством вызова цели compile'

    def libsDir = layout.buildDirectory.dir("libs/lib").get().asFile.absolutePath

    dependsOn 'custom-compile'     //  компиляция + копирование lib

    archiveBaseName = project.name
    archiveVersion = project.version.toString()

    copy {
        from configurations.runtimeClasspath
        into libsDir
    }

    from sourceSets.main.output

    manifest {
        attributes 'Main-Class': 'com.example.web4_2.Web4Application'

        def cpEntries = configurations.runtimeClasspath.files.collect {
            "lib/${it.name}"
        }
        attributes 'Class-Path': cpEntries.join(' ')
    }

    destinationDirectory = layout.buildDirectory.dir("libs")

    doLast {
        println "✅jar-архив успешно собран в: ${archiveFile.get().asFile.absolutePath.replace(projectDir.absolutePath + '/', '')}"
    }
}


tasks.register('custom-clean', Exec) {
    group = "custom"
    description = "удаление скомпилированных классов, всех временных файлов и jar-архива"

    def buildDir = layout.buildDirectory.get().asFile.absolutePath

    commandLine "rm", "-rf", buildDir

    doLast {
        println "✅все скомпилированные классы и jar-архивы удалены"
    }
}

tasks.register("custom-native2ascii") {

    group = "custom"
    description = "преобразование native2ascii для копий файлов локализации " + "(для тестирования сценария все строковые параметры необходимо вынести из классов в файлы локализации)"

    def convertToUnicode = new GroovyShell().evaluate(file('scripts/convertToUnicode.groovy'))


    def inputDir = file("src/main/resources/")
    def outputDir = layout.buildDirectory.dir("native2ascii").get().asFile

    inputs.dir inputDir
    outputs.dir outputDir

    doLast {
        if (!outputDir.exists()) {
            outputDir.mkdirs()
        }
        // Process each .properties file in the input directory
        fileTree(inputDir).matching {
            include "**/messages*.properties"
        }.each { file ->
            def relativePath = inputDir.toPath().relativize(file.toPath()).toString()
            def outputFile = new File(outputDir, relativePath)
            outputFile.parentFile.mkdirs()
            println "converting: ${file}"
            outputFile.withWriter("UTF-8") { writer ->
                file.eachLine("UTF-8") { line -> writer.writeLine((String) convertToUnicode(line))
                }
            }
        }
        println "✅конвертация завершена. результат в: ${outputDir}"
    }

}

tasks.register("custom-scp", Exec) {
    group = "custom"
    description = "перемещение собранного проекта по scp на выбранный сервер по завершению сборки. Предварительно необходимо выполнить сборку проекта (цель build)"

    dependsOn("custom-build")

    def jarFile = layout.buildDirectory.file("libs/${project.name}-${project.version}.jar").get().asFile.absolutePath

    def remoteHost = "helios.se.ifmo.ru"
    def remoteUser = "s409342"
    def remoteDirWebLab4 = "~/web_lab4"


    doFirst {
        println "Copying JAR to ${remoteUser}@${remoteHost}:${remoteDirWebLab4}"
    }

    commandLine "scp", "-P 2222", jarFile, "${remoteUser}@${remoteHost}:${remoteDirWebLab4}"

    doLast {
        println '✅jar-архив успешно скопирован на удаленный сервер'
    }
}

tasks.register("xml") {
    group = "custom"
    description = "валидация всех xml-файлов в проекте"

    def xmlFilesDir = layout.projectDirectory.dir("src/main/resources").asFileTree // путь к директории с xml-файлами

    doLast {
        def script = new GroovyShell().parse(file('scripts/validateXml.groovy'))

        xmlFilesDir.each { file ->
            if (file.absolutePath.endsWith(".xml")) {
                println "валидирую файл: ${file.name}\n"
                script.validateXmlFile(file)
            }

        }
        println "✅валидация успешно завершена"
    }
}

tasks.register("music") {
    group = "custom"
    description = "воспроизведение музыки по завершению сборки (цель build)"

    dependsOn "custom-build"

    def musicFile = file("src/main/resources/Макс Корж - Малый повзрослел.mp3") // путь до твоего файла

    doLast {
        if (!musicFile.exists()) {
            throw new GradleException("не будет подлой еврейской музыки, файл не найден: ${musicFile} (")
        }

        exec {
            executable = 'afplay'
            args = [musicFile.absolutePath]
        }
        println "✅музыка"
    }
}

import java.security.MessageDigest

tasks.register('doc') {
    group = 'custom'
    description = 'добавление в MANIFEST.MF MD5 и SHA-1 файлов проекта, а также генерация и добавление в архив javadoc по всем классам проекта.'

    dependsOn 'custom-compile'

    def outputDir = layout.buildDirectory.dir("classes/java/main/com/example/web4_2").get().asFile
    def manifestFile = layout.buildDirectory.file("tmp/custom-build/MANIFEST.MF").get().asFile
    def javadocDir = layout.buildDirectory.dir("docs/javadoc").get().asFile
    def javadocJar = layout.buildDirectory.file("docs/javadoc.jar").get().asFile

    doLast {
        println "генерирую контрольные суммы MD5 SHA-1..."

        def files = outputDir.listFiles().findAll { it.isFile() }

        def md5Digest = MessageDigest.getInstance("MD5")
        def sha1Digest = MessageDigest.getInstance("SHA-1")

        def md5Strings = []
        def sha1Strings = []

        files.each { file ->
            def bytes = file.bytes
            md5Digest.update(bytes)
            sha1Digest.update(bytes)

            def md5Hex = md5Digest.digest().encodeHex().toString()
            def sha1Hex = sha1Digest.digest().encodeHex().toString()

            md5Strings << "${file.name}: $md5Hex"
            sha1Strings << "${file.name}: $sha1Hex"

            // Обнуляем digest после каждого файла
            md5Digest.reset()
            sha1Digest.reset()
        }

        // Дописываем в MANIFEST
        manifestFile.parentFile.mkdirs()
        manifestFile.text += "\r\n" // переход для новых записей
        manifestFile.text += "MD5-Checksums: ${md5Strings.join(', ')}\r\n"
        manifestFile.text += "SHA1-Checksums: ${sha1Strings.join(', ')}\r\n"

        println "MD5 и SHA-1 добавлены в манифест"

        println "генерирую Javadoc..."

        ant.javadoc(destdir: javadocDir,
                sourcepath: sourceSets.main.java.srcDirs.join(File.pathSeparator),
                packagenames: "*",
                classpath: configurations.runtimeClasspath.asPath,
                encoding: "UTF-8")

        ant.jar(destfile: javadocJar,
                basedir: javadocDir)

        println "✅документация Javadoc успешно содана: ${javadocJar}"
    }
}

tasks.register('custom-diff') {
    group = 'custom'
    description = 'осуществляет проверку состояния рабочей копии, и, если изменения касаются классов, указанных в файле параметров выполняет commit в репозиторий git.'

    def paramFile = file('monitoring_classes.txt')

    inputs.file paramFile
    outputs.dir layout.buildDirectory.dir('git-status')

    doLast {
        def modifiedClasses = []
        def monitoredClasses = paramFile.readLines().collect {
            it.trim()
        }.findAll {
            it
        }

        def gitStatusResult = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'status', '--porcelain'
            standardOutput = gitStatusResult
        }

        def gitStatus = gitStatusResult.toString().trim()

        gitStatus.eachLine { line ->
            def parts = line.trim().split(" ", 2)
            def typeOfChange = parts[0] // M: Modified A: Added D: Deleted R: Renamed C: Copied U: Unmerged ??: Untracked
            def filePath = parts[1]


            if (filePath.endsWith('.java')) {
                def className = filePath.replace('.java', '').replace('/', '.')

                if (monitoredClasses.contains(className)) {
                    modifiedClasses << filePath
                    println "⚙️были внесены изменения касаемо этого класса: $className"
                }
            }
        }

        if (modifiedClasses) {
            println "⚙️сейчас я сделаю коммит..."
            exec {
                commandLine 'git', 'add', modifiedClasses.join(" ")
            }
            exec {
                commandLine 'git', 'commit', '-m', "committing changes for monitored classes: ${modifiedClasses.join(', ')}"
            }
            println "✅изменения касаемо классов ${modifiedClasses.join(', ')} были успешно закоммичены"
        } else {
            println "✅в классы, объявленные в monitoring_classes.txt не было внесено изменений"
        }
    }
}

tasks.register('custom-env') {
    group = 'custom'
    description = 'осуществляет сборку и запуск программы в альтернативных окружениях; ' + 'окружение задается версией java и набором аргументов виртуальной машины в файле параметров.'

    def envFile = file('env.properties')

    inputs.file envFile
    outputs.dir layout.buildDirectory.dir('env-output')

    doLast {
        def props = new Properties()
        envFile.withInputStream {
            props.load(it)
        }
        def javaVersion = props.getProperty('java.version')
        def jvmArgsList = props.getProperty('jvm.args', '').split("\\s+").findAll { it }

        println "🛠 используется Java версия: $javaVersion"
        println "🛠 JVM аргументы: $jvmArgsList"


        def jarPath = "${buildDir}/libs/web4_2-0.0.1-SNAPSHOT.jar"
        exec {
            executable("java")
            args(jvmArgsList + ["-jar", jarPath])
        }
    }
}

tasks.register('alt-helper-replace') {
    group = 'custom'
    description = 'создаёт альтернативную версию программы с измененными именами переменных и классов ' + '(используя задание replace/replaceregexp в файлах параметров) и упаковывает её в jar-архив.' + ' Для создания jar-архива использует цель build.'

    // я хочу копировать папку срц в альтсрцдир - в ней изменять согласно файлы
    // изменять глобальную переменную срцдир + вызывать build
    def srcDirs = sourceSets.main.java.srcDirs
    def altSrcDirs = layout.projectDirectory.dir("altSrc").asFile
    if (altSrcDirs.exists()) {
        project.delete(altSrcDirs)
    }
    altSrcDirs.mkdirs()
    copy {
        from srcDirs
        into altSrcDirs
    }
//    def testFolder = new File(altSrcDirs, "test")
//    if (testFolder.exists()) {
//        project.delete(testFolder)
//    }
    // как мне из altSrcDirs удалить папку тест?
    def replacementsFile = layout.projectDirectory.file("replacements.properties").asFile
    def replacements = new Properties()
    replacementsFile.withInputStream {
        replacements.load(it)
    }

    altSrcDirs.eachFileRecurse { file ->

        if (file.name.endsWith('.java')) {
            def text = file.text
            replacements.each { key, value ->
                println "⚙️заменяю $key на $value в ${file.name}..."
                text = text.replaceAll(key, value)
            }
            file.text = text

            replacements.each { key, value ->
                if (file.name == "${key}.java") {
                    println "⚙️переименовываю файл ${file.name} в ${value}.java..."
                    def newFile = new File(file.parentFile, "${value}.java")
                    if (!file.renameTo(newFile)) {
                        throw new GradleException("не удалось переименовать файл ${file.name} в ${newFile.name} (")
                    }
                    println "файл переименован: ${file.name} → ${newFile.name}"
                } else {
                    if (file.name.contains(key)) {
                        println "⚙️переименовываю файл ${file.name} в ${file.name.replace(key, value)}..."
                        value = file.name.replace(key, value)
                        def newFile = new File(file.parentFile, "${value}")
                        if (!file.renameTo(newFile)) {
                            throw new GradleException("не удалось переименовать файл ${file.name} в ${newFile.name} (")
                        }
                        println "файл переименован: ${file.name} → ${newFile.name}"

                    }
                }
            }
        }
    }


}
tasks.register('alt-helper-cleanup') {
    group = 'custom'
    description = 'очистка altSrc и сброс useAltSrc'

    doLast {
        println "⚙️очищаю altSrc и сбрасываю useAltSrc..."
        def altSrcDir = layout.projectDirectory.dir("altSrc").asFile

        if (altSrcDir.exists()) {
            project.delete(altSrcDir)
            println "✅altSrc удалён."
        }

        project.ext.useAltSrc = false
        println "✅project.ext.useAltSrc сброшен в false."
    }
}
tasks.register('alt-helper-print-success') {
    group = 'custom'
    description = 'выводит сообщение об успешной сборке альтернативной версии'
    dependsOn 'alt-helper-cleanup'

    doLast {
        println "✅альтернативная версия успешно собрана и упакована в jar-архив."
    }
}

tasks.register('custom-alt') {
    group = 'custom'
    description = 'создаёт альтернативную версию программы с измененными именами переменных и классов (используя задание replace/replaceregexp в файлах параметров) и упаковывает её в jar-архив.' + ' Для создания jar-архива использует цель build.'

    dependsOn 'alt-helper-replace'

    doFirst {
        project.ext.useAltSrc = true
    }

    finalizedBy 'custom-build', 'alt-helper-cleanup', 'alt-helper-print-success'

}


tasks.register('history') {
    group = 'custom'
    description = 'если проект не удаётся скомпилировать (цель compile), загружается предыдущая версия из репозитория git. '
    + 'Операция повторяется до тех пор, пока проект не удастся собрать, либо не будет получена самая первая ревизия ' +
            'из репозитория. Если такая ревизия найдена, то формируется файл, содержащий результат операции ' +
            'diff для всех файлов, измёненных в ревизии, следующей непосредственно за последней работающей.'

    def originalHead = ''
    def workingRevision = ''
    def previousRevision = ''
    def out = new ByteArrayOutputStream()


    doFirst {
        exec {
            commandLine 'git', 'rev-parse', 'HEAD'
            standardOutput = out
        }
        originalHead = out.toString().trim()

        exec {
            commandLine 'git', 'log', '--pretty=format:%H'
            standardOutput = out
        }

        List<String> gitLog = out.toString().trim().isEmpty() ? [] : out.toString().trim().split("\n").toList()

        println "⚙️загружено: ${gitLog.size()} коммитов репозитория"

        if (gitLog.size() == 0) {
            throw new GradleException("❌нет доступных коммитов в истории git(")
        }

        for (int i = 0; i < gitLog.size(); i++) {
            def rev = gitLog[i]
            println "⚙️переходим на ревизию: $rev"
            exec {
                commandLine 'git', 'checkout', rev
            }
            try {
                exec {
                    commandLine './gradlew', 'custom-compile'
                }
                println "✅проект успешно скомпилировался на ревизии: $rev"

                workingRevision = rev
                previousRevision = (i > 0) ? gitLog[i - 1] : null
                exec {
                    commandLine 'git', 'branch', '-f', 'master', rev
                }

                break
            } catch (Exception e) {
                println "❌ошибка компиляции на ревизии: $rev (("
            }
        }

        if (!workingRevision) {
            throw new GradleException("❌не удалось найти рабочую ревизию! даже самая первая не собирается (")
        }

        if (previousRevision) {
            println "⚙️формирую diff между $workingRevision и $previousRevision"
            def diffFile = layout.buildDirectory.file("history/diff.txt").get().asFile
            diffFile.parentFile.mkdirs()

            exec {
                commandLine 'git', 'diff', workingRevision, previousRevision
                standardOutput = new FileOutputStream(diffFile)
            }

            println "✅результат git diff успешно сохранён в: ${diffFile.absolutePath.replace(projectDir.absolutePath + '/', '')}"
        } else {
            println "✅рабочая ревизия — самая новая. нет следующей ревизии для diff."
        }
    }
}


tasks.register('team') {
    group = 'custom'
    description = 'осуществляет получение из git-репозитория 4 предыдущих ревизий, их сборку (по аналогии ' + 'с основной) и упаковку получившихся jar-файлов в zip-архив. Сборку реализовать посредством вызова цели build.'

    def teamBuildDir = layout.buildDirectory.dir("team-jars").get().asFile
    def zipOutput = layout.buildDirectory.file("team-jars/team_builds.zip").get().asFile

    doLast {
        def originalRev = getCurrentGitRevision()

        def revisions = getLastGitRevisions(4)

        if (teamBuildDir.exists()) {
            project.delete(teamBuildDir)
        }
        teamBuildDir.mkdirs()

        revisions.eachWithIndex { rev, idx ->
            println "⚙️переходим на ревизию: $rev"
            gitCheckout(rev)

            try {
                println "⚙️билд проекта на ревизии $rev"
                exec {
                    commandLine './gradlew', 'custom-build'
                }

                def jarName = "${project.name}-${project.version}-rev${idx + 1}.jar"
                def builtJar = file("${buildDir}/libs/${project.name}-${project.version}.jar")

                if (!builtJar.exists()) {
                    throw new GradleException("❌jar-файл не найден после сборки на ревизии: $rev")
                }

                copy {
                    from builtJar
                    into teamBuildDir
                    rename { jarName }
                }

                println "✅билд ревизии $rev успешно завершен!"

            } catch (Exception e) {
                println "❌ошибка сборки на ревизии $rev: ${e.message}"
            }
        }

        gitCheckout(originalRev)

        println "⚙️упаковываю jar-архивы в zip-архив..."
        ant.zip(destfile: zipOutput) {
            fileset(dir: teamBuildDir)
        }

        println "✅упаковка 4 последних ревизий завершена! " + "zip-архив находится здесь: ${zipOutput.absolutePath.replace(projectDir.absolutePath + '/', '')}"
    }
}

// Получить текущую ревизию
String getCurrentGitRevision() {
    def out = new ByteArrayOutputStream()
    exec {
        executable = "git"
        args = ["rev-parse", "HEAD"]
        workingDir = project.projectDir
        standardOutput = out
        errorOutput = out
        ignoreExitValue = true
    }
    return out.toString().trim()
}

// Получить N последних ревизий
List<String> getLastGitRevisions(int count) {
    def out = new ByteArrayOutputStream()
    exec {
        executable = "git"
        args = ["rev-list", "-n", "$count", "HEAD"]
        workingDir = project.projectDir
        standardOutput = out
        errorOutput = out
        ignoreExitValue = true
    }
    return out.toString().trim().split("\n").toList()
}

// Переключиться на ревизию
void gitCheckout(String revision) {
    exec {
        executable = "git"
        args = ["checkout", revision]
        workingDir = project.projectDir
    }
}

